# Chapter 15. Psi-SSA Form
**Francois de Ferriere**

In the SSA representation, each definition of a variable is given a unique name, and new pseudo-definitions are introduced on $\phi$-functions to merge values coming from different control-flow paths. An example is given in Fig. 15.1b. Each definition is an unconditional definition, and the value of a variable is the value of the expression on the unique assignment to this variable. This essential property of the SSA representation no longer holds when definitions may be conditionally executed. When a variable is defined by a predicated operation, the value of the variable will or will not be modified depending on the value of a guard register. As a result, the value of the variable after the predicated operation is either the value of the expression on the assignment if the predicate is true, or the value the variable had before this operation if the predicate is false. This is represented in Fig. 15.1c where we use the notation $p$? $a=\texttt{op}$ to indicate that an operation $a=\texttt{op}$ is executed only if predicate $p$ is true, and is ignored otherwise. We will also use the notation $\overline{p}$ to refer to the complement of predicate $p$. The goal of the $\psi$-SSA form advocated in this chapter is to express these conditional definitions while keeping the Static Single Assignment property.

## 15.1 Definition and Construction

Predicated operations are used to convert control-flow regions into straight-line code. Predicated operations may be used by the intermediate representation in an early stage of the compilation process as a result of inlining intrinsic functions. Lateron, the compiler may also generate predicated operations through if-conversion optimizations as described in Chap. 20.

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092228781.png)

In Fig. 15.1c, the use of $a$ on the last instruction refers to the variable $a_{1}$ if $p$ is $\mathsf{false}$, or to the variable $a_{2}$ if $p$ is $\mathsf{true}$. These multiple reaching definitions on the use of $a$ cannot be represented by the standard SSA representation. One possible representation would be to use the gated SSA form, presented in Chap. 14. In such a representation, the $\phi$-function would be augmented with the predicate $p$ to tell which value between $a_{1}$ and $a_{2}$ is to be considered. However, gated SSA is a completely different intermediate representation where the control flow is no longer represented. This representation is better suited to program interpretation than to optimizations at code-generation level as addressed in this chapter. Another possible representation would be to add a reference to $a_{1}$ on the definition of $a_{2}$. In this case, $p$$?a_{2}=\texttt{op2}\mid a_{1}$ would have the following semantic: $a_{2}$ takes the value computed by $\texttt{op2}$ if $p$ is $\mathsf{true}$, or holds the value of $a_{1}$ if $p$ is $\mathsf{false}$. The use of $a$ on the last instruction of Fig. 15.1c would now refer to the variable $a_{2}$, which holds the correct value. The drawback of this representation is that it adds dependencies between operations (here a flow dependence from $\texttt{op1}$ to $\texttt{op2}$), which would prevent code reordering for scheduling.

Our solution is presented in Fig. 15.1d. The $\phi$-function of the SSA code with control flow is "replaced" by a $\psi$-function on the corresponding predicated code, with information on the predicate associated with each argument. This representation is adapted to code optimization and code generation on a low-level intermediate representation. A $\psi$-function $a_{0}=\psi(p_{1}?a_{1},\ \ldots,\ p_{i}?a_{i},\ \ldots,\ p_{n}?a_{n})$ defines one variable, $a_{0}$, and takes a variable number of arguments $a_{i}$; each argument $a_{i}$ is associated with a predicate $p_{i}$. In the notation, the predicate $p_{i}$ will be omitted if $p_{i}\equiv\mathsf{true}$.

A $\psi$-function has the following properties:

* _It is an operation_: A $\psi$-function is a regular operation. It can occur at any location in a basic block where a regular operation is valid. Each argument $a_{i}$, and each predicate $p_{i}$, must be dominated by its definition.
* _It is predicated_: A $\psi$-function is a predicated operation, under the predicate $\bigcup_{k=1}^{n}p_{k}$, although this predicate is not explicit in the representation.

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092229675.png)

* _It has an ordered list of arguments_: The order of the arguments in a $\psi$-function is significant. A $\psi$-function is evaluated from left to right. The value of a $\psi$-function is the value of the rightmost argument whose predicate evaluates to true.
* _Rule on predicates_: The predicate $p_{i}$ associated with the argument $a_{i}$ in a $\psi$-function must be included in or equal to the predicate on the definition of the variable $a_{i}$. In other words, for the code $q$? $a_{i}=\texttt{op}$; $a_{0}=\psi\left(\ldots,\ p_{i}?a_{i},\ldots\right)$, we must have $p_{i}\subseteq q$ (or $p_{i}\Rightarrow q$).

A $\psi$-function can represent cases where variables are defined on arbitrary independent predicates such as $p$ and $q$ in the example of Fig. 15.2: For this example, during the SSA construction, a unique variable $a$ was renamed into the variables $a_{1}$, $a_{2}$, and $a_{3}$, and the variables $x_{1}$ and $x_{2}$ were introduced to merge values coming from different control-flow paths. In the control-flow version of the code, there is a control dependence between the basic block that defines $x_{1}$ and the operation that defines $a_{3}$, which means that the definition of $a_{3}$ must be executed after the value for $x_{1}$ has been computed. In the predicated form of this example, there are no longer any control dependencies between the definitions of $a_{1}$, $a_{2}$, and $a_{3}$. A compiler transformation can now freely move these definitions independently of each other, which may allow more optimizations to be performed on this code. However, the semantics of the original code requires that the definition of $a_{3}$ occurs after the definitions of $a_{1}$ and $a_{2}$. The order of the arguments in a $\psi$-function gives information on the original order of the definitions. We take the convention that the order of the arguments in a $\psi$-function is, from left to right, equal to the original order of their definitions, from top to bottom, in the control-flow dominance tree of the program in a non-SSA representation. This information is needed to maintain the correct semantics of the code during transformations of the $\psi$-SSA representation and to revert the code back to a non-$\psi$-SSA representation.

The construction of the $\psi$-SSA representation is a small modification to the standard algorithm to build an SSA representation (see Sect. 3.1). The insertion of $\psi$-functions is performed during the SSA renaming phase. During this phase, basic blocks are processed in their dominance order, and operations in each basic block are scanned from top to bottom. On an operation, for each predicated definition of a variable, a new $\psi$-function will be inserted just after the operation. Consider the definition of a variable $x$ under predicate $p_{2}$ ($p_{2}$? $x=\texttt{op}$); suppose that $x_{1}$ is the current version of $x$ before proceeding to op and that $x_{1}$ is defined through predicate $p_{1}$ (possibly true); after renaming $x$ into a freshly created version, say $x_{2}$, a $\psi$-function of the form $x=\psi(p_{1}?x_{1},p_{2}?x)$ is inserted right after op. Then the renaming of this new operation proceeds. The first argument of the $\psi$-function is already renamed and thus is not modified. The second argument is renamed into the current version of $x$, that is, $x_{2}$. On the definition of the $\psi$-function, the variable $x$ is given a new name, $x_{3}$, which becomes the current version for further references to the $x$ variable. This insertion and renaming of a $\psi$-function is shown in Fig. 15.3.

$\psi$-functions can also be introduced into an SSA representation by applying an if-conversion transformation, such as the one described in Chap. 20. Local transformations of control-flow patterns can also require the replacement of $\phi$-functions by $\psi$-functions.

## 15.2 SSA Algorithms

With this definition of the $\psi$-SSA representation, implicit data-flow links to predicated operations are now explicitly expressed through $\psi$-functions. The usual algorithms that perform optimizations or transformations on the SSA representation can now be easily adapted to the $\psi$-SSA representation, without compromising the efficiency of the transformations performed. Actually, within the $\psi$-SSA representation, predicated definitions behave exactly the same as non-predicated ones for optimizations on the SSA representation. Only the $\psi$-functions have to be treated in a specific way. As an example, the classical constant propagation algorithm under SSA can be easily adapted to the $\psi$-SSA representation. In this algorithm, the only modification concerns $\psi$-functions, which have to be handled using the same rules as with the $\phi$-functions. Other algorithms such as dead code elimination (see Chap. 3), global value numbering, partial redundancy elimination (see Chap. 11), and induction variable analysis (see Chap. 10) are examples of algorithms that can easily be adapted to this representation with little effort.

## 15.3 Psi-SSA Algorithms

In addition to standard algorithms that can be applied to $\psi$-functions and predicated code, a number of specific transformations can be performed on the $\psi$-functions, namely $\psi$-inlining, $\psi$-reduction, $\psi$-projection, $\psi$-permutation, and $\psi$-promotion.

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092229802.png)
![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092230193.png)

For a $\psi$-function $a_{0}=\psi\,(p_{1}?a_{1},\,\ldots,\,p_{i}?a_{i},\,\ldots,\,p_{n}?a_{n})$, these transformations are defined as follows:

$\psi$-**Inlining** recursively replaces in a $\psi$- function an argument $a_{i}$ that is defined on another $\psi$- function by the arguments of this other $\psi$-function. The predicate $p_{i}$ associated with argument $a_{i}$ will be distributed with an and operation over the predicates associated with the inlined arguments. This is shown in Fig. 15.4.

$\psi$-**Reduction** removes from a $\psi$-function an argument $a_{i}$ whose value will always be overridden by arguments on its right in the argument list. An argument $a_{i}$ associated with predicate $p_{i}$ can be removed if $p_{i}\subseteq\bigcup_{k=i+1}^{n}p_{k}$. This can be illustrated by the example of Fig. 15.5.

$\psi$-**Projection** creates from a $\psi$-function a new $\psi$-function on a restricted predicate, say $p$. In this new $\psi$-function, an argument $a_{i}$ initially guarded by $p_{i}$ will be guarded by the conjunction $p_{i}\wedge p$. If $p_{i}$ is known to be disjoint with $p$, $a_{i}$ actually contributes no value to the $\psi$-function and thus can be removed. $\psi$-projection on predicate $p$ is usually performed when the result of a $\psi$-function is used in an operation predicated by $p$. This is illustrated in Fig. 15.6.

$\psi$-**Permutation** changes the order of the arguments in a $\psi$-function. In a $\psi$-function, the order of the arguments is significant. Two arguments in a $\psi$-function can be permuted if the intersection of their associated predicate in the $\psi$-function is empty. An example of such a permutation is shown in Fig. 15.7.

$\psi$-**Promotion** changes one of the predicates used in a $\psi$-function to a larger predicate. The promotion must obey the following condition so that the semantics of the $\psi$-function is not altered by the transformation: consider an operation $a_{0}=\psi\,(p_{1}?x_{1},\,\ldots,\,p_{i}?x_{i},\,\ldots,\,p_{n}?x_{n})$ promoted into $a_{0}=\psi\,(p_{1}?a_{1},\,\ldots,\,p_{i}?x_{i},\,\ldots,\,p_{n}?x_{n})$

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092230499.png)
![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092230945.png)


$\psi\left(p_{1}?x_{1},\,\ldots,\,p_{i}^{\prime}?x_{i},\,\ldots,\,p_{n}?x_{n}\right)$ with $p_{i}\subseteq p_{i}^{\prime}$, and then $p_{i}^{\prime}$ must fulfil

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092230989.png)
where $p_{i}^{\prime}\backslash\bigcup_{k=i}^{n}p_{k}$ corresponds to the possible increase of the predicate of the $\psi$-function, $\bigcup_{k=1}^{n}p_{k}$. This promotion must also satisfy the properties of $\psi$-functions, and, in particular, that the predicate associated with a variable in a $\psi$-function must be included in or equal to the predicate on the definition of that variable (which itself can be a $\psi$-function). A simple $\psi$-promotion is illustrated in Fig. 15.8c.

The $\psi$-SSA representation can be used on a partially predicated architecture, where only a subset of the instructions supports a predicate operand. Figure 15.8 shows an example where some code with control-flow edges was transformed into a linear sequence of instructions. Taking the example of an architecture where the ADD operation cannot be predicated, the ADD operation must be speculated under the true predicate. On an architecture where the ADD operation can be predicated, it may also be profitable to perform speculation in order to reduce the number of predicates on predicated code and to reduce the number of operations to compute these predicates. Once speculation has been performed on the definition of a variable used in a $\psi$-function, the predicate associated with this argument can be promoted, provided that the semantics of the $\psi$-function is maintained (Eq. 15.1).

Usually, the first argument of a $\psi$-function can be promoted under the true predicate. Also, when disjoint conditions are computed, one of them can be promoted to include the other conditions, usually reducing the number of predicates. A side effect of this transformation is that it may increase the number of copy instructions to be generated during the $\psi$-SSA destruction phase, as will be explained in the following section.

## 15.4 Psi-SSA Destruction

The SSA destruction phase reverts an SSA representation into a non-SSA representation. This phase must be adapted to the $\psi$-SSA representation. This algorithm uses $\psi$-$\phi$-webs to create a conventional $\psi$-SSA representation. The notion of $\phi$-webs is extended to $\phi$ and $\psi$ operations so as to derive the notion of conventional $\psi$-SSA ($\psi$-C-SSA) form. A $\psi$-$\phi$-web is a non-empty, minimal set of variables such that if two variables are referenced on the same $\phi$ or $\psi$-function, then they are in the same $\psi$-$\phi$-web. The property of the $\psi$-C-SSA form is that the renaming into a single variable of all variables that belong to the same $\psi$-$\phi$-web, and the removal of the $\psi$ and $\phi$ functions, results in a program with the same semantics as the original program.

Now, consider Fig. 15.9 to illustrate the transformations that must be performed to convert a program from a $\psi$-SSA form into a program in $\psi$-C-SSA form.

Looking at the first example (Fig. 15.9a), the dominance order of the definitions for the variables $a$ and $b$ differs from their order from left to right in the $\psi$-function. Such code may appear after a code motion algorithm has moved the definitions for $a$ and $b$ relatively to each other. Here, the renaming of the variables $a$, $b$, and $x$ into a single variable will not restore the semantics of the original program. The order in which the definitions of the variables $a$, $b$, and $x$ occur must be corrected. This is done through the introduction of the variable $c$ that is defined as a predicated copy of the variable $b$, after the definition of $a$. Now, the renaming of the variables $a$, $c$, and $x$ into a single variable will result in the correct behaviour.

In Fig. 15.9d, the definition of the variable $b$ has been speculated. However, according to the semantics of the $\psi$-function, the variable $x$ will only be assigned the value of $b$ when $p$ is true. A new variable $c$ must be defined as a predicated copy

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092231348.png)

of the variable $b$, after the definition of $b$ and $p$; in the $\psi$-function, variable $b$ is then replaced by variable $c$. The renaming of variables $a$, $c$, and $x$ into a single variable will now follow the correct behaviour.

In Fig. 15.9g, the renaming of the variables $a$, $b$, $c$, $x$, and $y$ into a single variable will not give the correct semantics. In fact, the value of $a$ used in the second $\psi$-function would be overridden by the definition of $b$ before the definition of the variable $c$. Such code will occur after copy folding has been applied on a $\psi$-SSA representation. We see that the value of $a$ has to be preserved before the definition of $b$. This is done through the definition of a new variable ($d$ here), resulting in the code given in Fig. 15.9h. Now, the variables $a$, $b$, and $x$ can be renamed into a single variable, and the variables $d$, $c$, and $y$ will be renamed into another variable, resulting in a program in a non-SSA form with the correct behaviour.

We will now present an algorithm that will transform a program from a $\psi$-SSA form into its $\psi$-C-SSA form. This algorithm comprises three parts:
* _Psi-normalize_: This phase puts all $\psi$-functions in what we call a _normalized_ form.
* _Psi-web_: This phase grows $\psi$-webs from $\psi$-functions and introduces repair code where needed such that each $\psi$-web is interference-free.
* _Phi-web_: This phase is the standard SSA destruction algorithm (e.g., see Chap. 21) with the additional constraint that all variables in a $\psi$-web must be coalesced together. This can be done using the pinning mechanism presented in Chap. 21.

We now detail the implementation of each of the first two parts.

### 15.4.1 Psi-Normalize

We define the notion of _normalized-$\psi$_. The normalized form of a $\psi$-function has two characteristics:

* The order of the arguments in a normalized-$\psi$-function is, from left to right, equal to the order of their definitions, from top to bottom, in the control-flow dominance tree.
* The predicate associated with each argument in a normalized-$\psi$-function is equal to the predicate used on the unique definition of this argument.

These two characteristics correspond respectively to the two cases presented in Fig. 15.9a, d. When some arguments of a $\psi$-function are also defined by $\psi$-functions, the normalized-$\psi$ characteristics must hold on a virtual $\psi$-function where $\psi$-inlining has been performed on these arguments.

When $\psi$-functions are created during the construction of the $\psi$-SSA representation, they are naturally built in their normalized form. Later, transformations are applied to the $\psi$-SSA representation. Predicated definitions may be moved relatively to each other. Also, operation speculation and copy folding may enlarge the domain of the predicate used on the definition of a variable. These transformations may cause some $\psi$-functions to be in a non-normalized form.

#### **PSI-Normalize Implementation**

Each $\psi$-function is processed independently. An analysis of the $\psi$-functions in a top-down traversal of the dominator tree reduces the amount of repair code that is inserted during this pass. We only detail the algorithm for such a traversal.

For a $\psi$-function $a_{0}=\psi(\,p_{1}?a_{1},\ \ldots,\ p_{i}?a_{i},\ \ldots,\ p_{n}?a_{n})$, the argument list is processed from left to right. For each argument $a_{i}$, the predicate $p_{i}$ associated with this argument in the $\psi$-function and the predicate used on the definition of this argument are compared. If they are not equal, a new variable $a^{\prime}_{i}$ is introduced and is initialized at the highest point in the dominator tree after the definitions of $a_{i}$ and $p_{i}$. $a^{\prime}_{i}$ is defined by the operation $p_{i}\?\ a^{\prime}_{i}=a_{i}$. Then $a_{i}$ is replaced by $a^{\prime}_{i}$ in the $\psi$-function.

Next, we consider the dominance order of the definition for $a_{i}$ in respect of the definition for $a_{i-1}$. When $a_{i}$ is defined on a $\psi$-function, we recursively look for the definition of the first argument of this $\psi$-function, until a definition on a non-$\psi$-function is found. If the definition we found for $a_{i}$ dominates the definition for $a_{i-1}$, a correction is needed. If the predicates $p_{i-1}$ and $p_{i}$ are disjoint, a $\psi$-permutation can be applied between $a_{i-1}$ and $a_{i}$, so as to reflect into the $\psi$-function the actual dominance order of the definitions of $a_{i-1}$ and $a_{i}$. If $\psi$-permutation cannot be applied, a new variable $a^{\prime}_{i}$ is created for repair. $a^{\prime}_{i}$ is defined by the operation $p_{i}?a^{\prime}_{i}=a_{i}$. This copy operation is inserted at the highest point that is dominated by the definitions of $a_{i-1}$ and $a_{i}$.1 Then $a_{i}$ is replaced in the $\psi$-function by $a^{\prime}_{i}$.

Footnote 1: When $a_{i}$ is defined by a $\psi$-function, its definition may appear after the definition for $a_{i-1}$, although the non-$\psi$ definition for $a_{i}$ appears before the definition for $a_{i-1}$.

The algorithm continues with the argument $a_{i+1}$, until all arguments of the $\psi$-function are processed. When all arguments are processed, the $\psi$ is in its normalized form. When all $\psi$ functions are processed, the function will contain only normalized-$\psi$-functions.

### 15.4.2 Psi-web

The role of the psi-web phase is to repair the $\psi$-functions that are part of a non-interference-free $\psi$-web. This case corresponds to the example presented in Fig. 15.9g. In the same way as there is a specific point of use for arguments on $\phi$-functions for liveness analysis (e.g., see Sect. 21.2), we give a definition of the actual point of use of arguments on normalized $\psi$-functions for liveness analysis. With this definition, liveness analysis is computed accurately, and an interference graph can be built. The cases where repair code is needed can be easily and accurately detected by observing that variables in a $\psi$-function interfere.

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092232799.png)

#### Liveness and Interferences in Psi-SSA

Consider the code in Fig. 15.10b. Instead of using a representation with $\psi$-functions, predicated definitions have been modified to make a reference to the value the predicated definition will have in the event that the predicate evaluates to false. In this example, we use the notation of the select operator $x\,=\,$_cond_$?$_exp1_$:$_exp2_ that assigns _exp1_ to $x$ if _cond_ is true and _exp2_ otherwise. Each of the predicated definitions makes explicit use of the variable immediately to its left in the argument list of the original $\psi$-function from Fig. 15.10a. We can see that a renaming of the variables $a$, $b$, $c$, and $x$ into a single representative name will still compute the same value for the variable $x$. Note that this transformation can only be performed on normalized $\psi$-functions, since the definition of an argument must be dominated by the definition of the argument immediately to its left in the argument list of the $\psi$-function, and the same predicate must be used on the definition of an argument and with this argument in the $\psi$ operation. Using this equivalence for the representation of a $\psi$-function, we now give a definition of the point of use for the arguments of a $\psi$-function.

**Definition 15 (Use Points)**: Let $a_{0}=\psi\,(p_{1}?a_{1},\,\ldots,\,p_{l}?a_{i},\,\ldots,\,p_{n}?a_{n})$ be a normalized $\psi$-function. For $i\,<\,n$, the point of use of argument $a_{i}$ occurs at the operation that defines $a_{i+1}$. The point of use for the last argument $a_{n}$ occurs at the $\psi$-function itself.

Given this definition of point of use of $\psi$-function arguments, and using the usual point of use of $\phi$-function arguments, a traditional liveness analysis can be run. Then an interference graph can be built to collect the interferences between variables involved in $\psi$ or $\phi$-functions. For the construction of the interference graph, an interference between two variables that are defined on disjoint predicates can be ignored.

####  Repairing Interferences on $\psi$-Functions

We now present an algorithm that resolves the interferences as it builds the $\psi$-webs. A pseudo-code is given in Algorithm 15.1. First, the $\psi$-webs are initialized with a single variable per $\psi$-web. Next, $\psi$-functions are processed one at a time, in no specific order, merging when non-interfering the $\psi$-webs of its operands together. Two $\psi$-webs interfere if at least one variable in the first $\psi$-web interferes with at least one variable in the other one. The arguments of the $\psi$-function, say $a_{0}=\psi\,(p_{1}?a_{1},\,\ldots,\,p_{i}?a_{i},\,\ldots,\,p_{n}?a_{n})$, are processed from right ($a_{n}$) to left ($a_{1}$). If the $\psi$-web that contains $a_{i}$ does not interfere with the $\psi$-web that contains $a_{0}$, they are merged together. Otherwise, repair code is needed. A new variable, $a^{\prime}_{i}$, is created and is initialized with a predicated copy $p_{i}$$?\,a^{\prime}_{i}=a_{i}$, inserted just abovethe definition for $a_{i+1}$, or just above the $\psi$-function in case of the last argument. The current argument $a_{i}$ in the $\psi$-function is replaced by the new variable $a_{i}^{\prime}$. The interference graph is updated. This can be done by considering the set of variables, say $U$, that $a_{i}$ interferes with. For each $u\in U$, if $u$ is in the merged $\psi$-web, it should not interfere with $a_{i}^{\prime}$; if the definition of $u$ dominates the definition of $a_{i}$, it is live through the definition of $a_{i}$, thus it should be made interfering with $a_{i}^{\prime}$; last, if the definition of $a_{i}$ dominates the definition of $b$, it should be made interfering only if this definition is within the live range of $a_{i}^{\prime}$ (see Chap. 9).

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092233081.png)

Consider the code in Fig. 15.11 to see how this algorithm works. The liveness on the $\psi$-function creates a live range for variable $a$ that extends down to the definition

![image.png](https://blog-1314253005.cos.ap-guangzhou.myqcloud.com/202310092233079.png)
of $b$, but not further down. Thus, the variable $a$ does not interfere with the variables $b$, $c$, or $x$. The live range for variable $b$ extends down to its use in the definition of variable $d$. This live range interferes with the variables $c$ and $x$. The live range for variable $c$ extends down to its use in the $\psi$-function that defines the variable $x$. At the beginning of the processing on the $\psi$-function $x=\psi\left(p?a,q?b,r?c\right)$, $\psi$-webs are singletons $\{a\},\ \{b\},\ \{c\},\ \{x\},\ \{d\}$. The argument list is processed from right to left, i.e., starting with variable $c$. $\{c\}$ does not interfere with $\{x\}$, and they can be merged together, resulting in $psiWeb=\{x,\,c\}$. Next, variable $b$ is processed. Since it interferes with both $x$ and $c$, repair code is needed. A variable $b$' is created and is initialized just below the definition for $b$, as a predicated copy of $b$. The interference graph is updated conservatively, with no changes. $psiWeb$ now becomes $\{x,\,b^{\prime},\,c\}$. Then variable $a$ is processed, and as no interference is encountered, $\{a\}$ is merged to $psiWeb$. The final code after SSA destruction is shown in Fig. 15.11c.

## 15.5 Further Reading

In this chapter, we have mainly described the $\psi$-SSA representation and have detailed specific transformations that can be performed thanks to this representation. More details on the implementation of the $\psi$-SSA algorithms, and figures on the benefits of this representation, can be found in [275] and [104].

We mentioned in this chapter that a number of classical SSA-based algorithms can be easily adapted to the $\psi$-SSA representation, usually by just adapting the rules on the $\phi$-functions to the $\psi$-functions. Among these algorithms, we can mention the constant propagation algorithm described in [303], dead code elimination [202], global value numbering [76], partial redundancy elimination [73], and induction variable analysis [306], which have already been implemented into a $\psi$-SSA framework.

There are also other SSA representations that can handle predicated instructions, of which the Predicated SSA representation [58]. This representation is targeted at very low-level optimization to improve operation scheduling in the presence of predicated instructions. Another representation is the gated SSA form, presented in Chap. 14.

The $\psi$-SSA destruction algorithm presented in this chapter is inspired from the SSA destruction algorithm of Sreedhar et al. [267], which introduces repair code when needed as it grows $\phi$-webs from $\phi$-functions. The phi-web phase mentioned in this chapter to complete the $\psi$-SSA destruction algorithm can use exactly the same approach by simply initializing $\psi$-$\phi$-webs by $\psi$-webs.
